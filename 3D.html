<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Landing — 3D Hero manipulável</title>
    <style>
        :root {
            --bg: #0f1724;
            --hero-height: 80vh;
            --accent: #7dd3fc;
            --glass: rgba(255, 255, 255, 0.06);
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            background: linear-gradient(180deg, #071026 0%, #0f1724 100%);
            color: #e6eef8;
        }

        /* Layout */
        .hero {
            height: var(--hero-height);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .hero__content {
            position: absolute;
            left: 40px;
            top: 40px;
            z-index: 5;
            max-width: 460px;
            background: var(--glass);
            padding: 18px;
            border-radius: 12px;
            backdrop-filter: blur(6px);
            box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        .hero__title {
            margin: 0 0 8px 0;
            font-size: 28px;
            line-height: 1.05;
        }

        .hero__subtitle {
            margin: 0 0 12px 0;
            color: #bcd8f0;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button.btn {
            border: 0;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
            color: var(--accent);
            border: 1px solid rgba(125, 211, 252, 0.14);
            font-weight: 600;
        }

        button.btn.secondary {
            color: #c6d4e9;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }

        /* Canvas fills hero */
        #heroCanvas {
            width: 100%;
            height: 100%;
            display: block;
            /* remove inline gap */
        }

        /* Simple footer under hero */
        .below {
            padding: 36px;
            max-width: 1000px;
            margin: 0 auto;
            color: #cbdaf0;
        }

        /* small helper */
        .hint {
            font-size: 13px;
            color: #98b7d6;
            margin-top: 8px;
        }

        @media (max-width:720px) {
            .hero__content {
                left: 16px;
                top: 16px;
                right: 16px;
                max-width: none;
            }
        }
    </style>
</head>

<body>

    <section class="hero" id="hero">
        <!-- UI overlay -->
        <div class="hero__content" role="region" aria-label="controles 3D">
            <h1 class="hero__title">Experimente um objeto 3D</h1>
            <p class="hero__subtitle">Gire com o mouse, arraste o objeto, alterne entre cubo e árvore.</p>

            <div class="controls" role="toolbar">
                <button id="btnCube" class="btn">Cubo</button>
                <button id="btnTree" class="btn secondary">Árvore</button>
                <button id="btnReset" class="btn secondary">Resetar</button>
                <button id="btnAuto" class="btn">Auto-rot.</button>
            </div>
            <div class="hint">Clique e arraste para rotacionar a câmera — use o botão <strong>Auto-rot.</strong> para
                animação.</div>
        </div>

        <!-- three.js canvas -->
        <canvas id="heroCanvas" aria-hidden="false"></canvas>
    </section>

    <div class="below">
        <h2>Landing simples</h2>
        <p>Espaço para chamadas, textos e CTA. O elemento 3D acima é independente e pode ser substituído por modelos
            glTF/GLB se quiser mais realismo.</p>
    </div>

''
    <!-- Place scripts at the end of body for correct order and to ensure THREE is defined -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DragControls.js"></script>
    <script>
        // --- Básico: cena, câmera, renderer
        const canvas = document.getElementById('heroCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, document.getElementById('hero').clientHeight);
        renderer.physicallyCorrectLights = true;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x071026); // combina com CSS

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / (document.getElementById('hero').clientHeight), 0.1, 1000);
        camera.position.set(0, 1.6, 4);

        // luzes
        const amb = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(amb);

        const dir = new THREE.DirectionalLight(0xffffff, 0.9);
        dir.position.set(5, 10, 7);
        scene.add(dir);

        // chão sutil (plano para sombras visuais)
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            new THREE.MeshStandardMaterial({ color: 0x071026, metalness: 0.1, roughness: 0.9 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.4;
        scene.add(ground);

        // group que conterá o modelo atual (cubo ou árvore)
        const modelGroup = new THREE.Group();
        scene.add(modelGroup);

        // materiais reutilizáveis
        const matColor = (hex) => new THREE.MeshStandardMaterial({ color: hex, metalness: 0.2, roughness: 0.4 });

        // cria cubo
        function makeCube() {
            const geo = new THREE.BoxGeometry(1.4, 1.4, 1.4);
            const mesh = new THREE.Mesh(geo, matColor(0x7dd3fc));
            mesh.castShadow = true;
            mesh.name = "manipulable";
            return mesh;
        }

        // cria árvore simples (tronco + copa)
        function makeTree() {
            const tree = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 0.9, 12), matColor(0x8b5a2b));
            trunk.position.y = -0.05;
            tree.add(trunk);

            const foliage1 = new THREE.Mesh(new THREE.ConeGeometry(0.9, 1.0, 12), matColor(0x16a34a));
            foliage1.position.y = 0.6;
            tree.add(foliage1);

            const foliage2 = new THREE.Mesh(new THREE.ConeGeometry(0.6, 0.8, 12), matColor(0x059669));
            foliage2.position.y = 1.05;
            tree.add(foliage2);

            tree.scale.set(0.9, 0.9, 0.9);
            tree.name = "manipulable";
            return tree;
        }

        // adicionar primeiro modelo (cubo)
        let activeMesh = null;
        function setModel(type = 'cube') {
            // limpa group
            while (modelGroup.children.length) modelGroup.remove(modelGroup.children[0]);
            if (type === 'cube') activeMesh = makeCube();
            else activeMesh = makeTree();

            // centraliza
            activeMesh.position.set(0, 0, 0);
            modelGroup.add(activeMesh);

            // atualizar DragControls (rebind)
            bindDragControls();
        }

        // CONTROLS
        const orbit = new THREE.OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        orbit.dampingFactor = 0.08;
        orbit.enablePan = false;
        orbit.minDistance = 1.2;
        orbit.maxDistance = 10;

        // DragControls: permite arrastar o objeto
        let dragControls = null;
        function bindDragControls() {
            // destrói anterior
            if (dragControls) {
                dragControls.deactivate();
                dragControls.dispose();
                dragControls = null;
            }
            // Pegamos objetos com nome 'manipulable' dentro do group
            const objects = [];
            modelGroup.traverse((o) => { if (o.isMesh && o.name === 'manipulable') objects.push(o); });
            if (objects.length === 0) return;

            dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
            dragControls.addEventListener('dragstart', (e) => {
                orbit.enabled = false;
                // opcional: realce
                if (e.object.material && e.object.material.emissive) e.object.material.emissive = new THREE.Color(0x222222);
            });
            dragControls.addEventListener('dragend', (e) => {
                orbit.enabled = true;
                if (e.object.material && e.object.material.emissive) e.object.material.emissive = new THREE.Color(0x000000);
            });
        }

        // responsividade: redimensionar apenas a área do hero (mantém resto da página)
        function onWindowResize() {
            const hero = document.getElementById('hero');
            const height = hero.clientHeight;
            renderer.setSize(window.innerWidth, height);
            camera.aspect = window.innerWidth / height;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', onWindowResize);

        // animação
        let clock = new THREE.Clock();
        let autoRotate = false;
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if (autoRotate) {
                modelGroup.rotation.y += dt * 0.6; // gira o modelo
            }

            orbit.update();
            renderer.render(scene, camera);
        }

        // UI bindings
        document.getElementById('btnCube').addEventListener('click', () => {
            setModel('cube');
            document.getElementById('btnCube').classList.remove('secondary');
            document.getElementById('btnTree').classList.add('secondary');
        });
        document.getElementById('btnTree').addEventListener('click', () => {
            setModel('tree');
            document.getElementById('btnTree').classList.remove('secondary');
            document.getElementById('btnCube').classList.add('secondary');
        });
        document.getElementById('btnReset').addEventListener('click', () => {
            // reset câmera e posições
            camera.position.set(0, 1.6, 4);
            orbit.target.set(0, 0, 0);
            orbit.update();
            modelGroup.rotation.set(0, 0, 0);
            autoRotate = false;
            document.getElementById('btnAuto').textContent = 'Auto-rot.';
        });
        document.getElementById('btnAuto').addEventListener('click', (e) => {
            autoRotate = !autoRotate;
            e.currentTarget.textContent = autoRotate ? 'Parar' : 'Auto-rot.';
        });

        // Inicialização
        setModel('cube');
        onWindowResize();
        animate();

        // dica: clique no canvas para focar e test
        canvas.addEventListener('pointerdown', () => canvas.focus());
    
    </script>
</body>

</html>